#!/usr/bin/env node

import {
  existsSync,
  fstat,
  mkdirSync,
  readFileSync,
  writeFileSync,
} from "fs-extra";
import { join } from "path";
import fetch from "node-fetch";

const projectPath = process.cwd();
const packagePath = join(projectPath, "package.json");

function fail(message: string): never {
  console.error(message);
  process.exit(1);
}

function readJSONFile(jsonPath: string): any {
  try {
    const packageData = readFileSync(packagePath, "utf8");
    const modulePackage = JSON.parse(packageData);
    return modulePackage;
  } catch (e) {
    fail(`Could not read JSON from ${jsonPath}`);
  }
}

const modulePackage = readJSONFile(packagePath);

if (!modulePackage.zerve)
  fail(`package.json does not have a zerve configuration`);

const { zerve: localZerveConfig } = modulePackage;

const zerveGeneratedDir = join(projectPath, "zerve");

console.log("==== Zerve-Sync ====");

if (!existsSync(zerveGeneratedDir)) {
  console.log('> Creating "zerve" directory');
  mkdirSync(zerveGeneratedDir);
}

Promise.all(
  Object.entries(localZerveConfig.dynamicSync).map(
    async ([zDynamicName, url]) => {
      console.log(`== Syncronizing ./zerve/${zDynamicName} from ${url} ==`);
      const parsedURL = String(url).match(/^(https?:\/\/)([^\/]+)\/(.+)$/);
      if (!parsedURL) fail(`Invalid dynamicSync URL: ${url}`);
      const [_fullUrl, protocol, origin, path] = parsedURL;
      const zURL = `${protocol}${origin}/.z/${path}`;
      const res = await fetch(zURL);
      const zClientPath = join(zerveGeneratedDir, zDynamicName);
      if (!existsSync(zClientPath)) {
        console.log(`> Creating "zerve/${zDynamicName}" client directory`);
        mkdirSync(zClientPath);
      }
      const zStoreFullData = await res.json();
      const { $schemas: zStoreSchemas, ...zStoreData } = zStoreFullData;
      const zFileValues = Object.fromEntries(
        Object.entries(zStoreData).map(([fileName, file]) => [
          fileName,
          file.value,
        ])
      );
      const zFileSchemas = Object.fromEntries(
        Object.entries(zStoreData).map(([fileName, file]) => [
          fileName,
          file.schema,
        ])
      );
      const zClientFileData = `
// Do not touch this file. It is generated by Zerve-Sync
// To update the file, modify the zerve field in package.json.zerve and run "npx zerve-sync"

import * as zStoreData from './data-sync.json';
import * as zStoreSchema from './schema-sync.json';
import { createZStoreClient } from '@zerve/client/StoreClient';

const zStoreProtocol = "${protocol}";
const zStoreOrigin = "${origin}";
const zStorePath = "${path}";

const zClient = createZStoreClient(
  zStoreProtocol,
  zStoreOrigin,
  zStorePath,
  zStoreSchema,
  zStoreData
);

${Object.entries(zFileSchemas)
  .map(
    ([fileName, fileSchema]) =>
      `export const ${fileName} = zClient.createAccessor("${fileName}", ${JSON.stringify(
        fileSchema,
        null,
        2
      )});`
  )
  .join("\n")}

export const FF = zClient.createAccessor('FF');
`;
      console.log(`> Writing "zerve/${zDynamicName}/index.ts"`);
      writeFileSync(join(zClientPath, "index.ts"), zClientFileData);
      console.log(`> Writing "zerve/${zDynamicName}/data-sync.json"`);
      writeFileSync(
        join(zClientPath, "data-sync.json"),
        JSON.stringify(zFileValues, null, 2)
      );
      console.log(`> Writing "zerve/${zDynamicName}/schema-sync.json"`);
      writeFileSync(
        join(zClientPath, "schema-sync.json"),
        JSON.stringify(
          {
            schemas: zStoreSchemas,
            files: zFileSchemas,
          },
          null,
          2
        )
      );
    }
  )
).catch((e) => {
  console.error(e);
  fail("Could not sync dynamic config");
});
