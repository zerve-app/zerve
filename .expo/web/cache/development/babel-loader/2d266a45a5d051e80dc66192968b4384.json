{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useCallback, useRef, useState } from \"react\";\nexport function useControlledState(value, defaultValue, onChange) {\n  var _useState = useState(value || defaultValue),\n      _useState2 = _slicedToArray(_useState, 2),\n      stateValue = _useState2[0],\n      setStateValue = _useState2[1];\n\n  var ref = useRef(value !== undefined);\n  var wasControlled = ref.current;\n  var isControlled = value !== undefined;\n  var stateRef = useRef(stateValue);\n\n  if (wasControlled !== isControlled) {\n    console.warn(\"WARN: A component changed from \" + (wasControlled ? 'controlled' : 'uncontrolled') + \" to \" + (isControlled ? 'controlled' : 'uncontrolled') + \".\");\n  }\n\n  ref.current = isControlled;\n  var setValue = useCallback(function (value) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var onChangeCaller = function onChangeCaller(value) {\n      if (onChange) {\n        if (!Object.is(stateRef.current, value)) {\n          for (var _len2 = arguments.length, onChangeArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            onChangeArgs[_key2 - 1] = arguments[_key2];\n          }\n\n          onChange.apply(void 0, [value].concat(onChangeArgs));\n        }\n      }\n\n      if (!isControlled) {\n        stateRef.current = value;\n      }\n    };\n\n    if (typeof value === 'function') {\n      var updateFunction = function updateFunction(oldValue) {\n        for (var _len3 = arguments.length, functionArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          functionArgs[_key3 - 1] = arguments[_key3];\n        }\n\n        var interceptedValue = value.apply(void 0, [isControlled ? stateRef.current : oldValue].concat(functionArgs));\n        onChangeCaller.apply(void 0, [interceptedValue].concat(args));\n\n        if (!isControlled) {\n          return interceptedValue;\n        }\n\n        return oldValue;\n      };\n\n      setStateValue(updateFunction);\n    } else {\n      if (!isControlled) {\n        setStateValue(value);\n      }\n\n      onChangeCaller.apply(void 0, [value].concat(args));\n    }\n  }, [isControlled, onChange]);\n\n  if (isControlled) {\n    stateRef.current = value;\n  } else {\n    value = stateValue;\n  }\n\n  return [value, setValue];\n}\nexport function clamp(value, min, max) {\n  if (min === void 0) {\n    min = -Infinity;\n  }\n\n  if (max === void 0) {\n    max = Infinity;\n  }\n\n  var newValue = Math.min(Math.max(value, min), max);\n  return newValue;\n}\nexport function snapValueToStep(value, min, max, step) {\n  var remainder = (value - (isNaN(min) ? 0 : min)) % step;\n  var snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min;\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor((max - min) / step) * step;\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(max / step) * step;\n  }\n\n  var string = step.toString();\n  var index = string.indexOf('.');\n  var precision = index >= 0 ? string.length - index : 0;\n\n  if (precision > 0) {\n    var pow = Math.pow(10, precision);\n    snappedValue = Math.round(snappedValue * pow) / pow;\n  }\n\n  return snappedValue;\n}\nexport function toFixedNumber(value, digits, base) {\n  if (base === void 0) {\n    base = 10;\n  }\n\n  var pow = Math.pow(base, digits);\n  return Math.round(value * pow) / pow;\n}","map":{"version":3,"sources":["packages/@react-stately/utils/src/useControlledState.ts","packages/@react-stately/utils/src/number.ts"],"names":["useState","value","ref","useRef","wasControlled","isControlled","stateRef","console","setValue","useCallback","args","onChangeCaller","onChangeArgs","Object","onChange","updateFunction","functionArgs","interceptedValue","setStateValue","min","Infinity","max","newValue","Math","remainder","isNaN","snappedValue","step","string","index","precision","pow","base"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useRef, useState} from 'react';\n\nexport function useControlledState<T>(\n  value: T,\n  defaultValue: T,\n  onChange: (value: T, ...args: any[]) => void\n): [T, (value: T | ((prevState: T) => T), ...args: any[]) => void]  {\n  let [stateValue, setStateValue] = useState(value || defaultValue);\n  let ref = useRef(value !== undefined);\n  let wasControlled = ref.current;\n  let isControlled = value !== undefined;\n  // Internal state reference for useCallback\n  let stateRef = useRef(stateValue);\n  if (wasControlled !== isControlled) {\n    console.warn(`WARN: A component changed from ${wasControlled ? 'controlled' : 'uncontrolled'} to ${isControlled ? 'controlled' : 'uncontrolled'}.`);\n  }\n\n  ref.current = isControlled;\n\n  let setValue = useCallback((value, ...args) => {\n    let onChangeCaller = (value, ...onChangeArgs) => {\n      if (onChange) {\n        if (!Object.is(stateRef.current, value)) {\n          onChange(value, ...onChangeArgs);\n        }\n      }\n      if (!isControlled) {\n        stateRef.current = value;\n      }\n    };\n\n    if (typeof value === 'function') {\n      // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n      // when someone using useControlledState calls setControlledState(myFunc)\n      // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n      // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n      // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n      let updateFunction = (oldValue, ...functionArgs) => {\n        let interceptedValue = value(isControlled ? stateRef.current : oldValue, ...functionArgs);\n        onChangeCaller(interceptedValue, ...args);\n        if (!isControlled) {\n          return interceptedValue;\n        }\n        return oldValue;\n      };\n      setStateValue(updateFunction);\n    } else {\n      if (!isControlled) {\n        setStateValue(value);\n      }\n      onChangeCaller(value, ...args);\n    }\n  }, [isControlled, onChange]);\n\n  // If a controlled component's value prop changes, we need to update stateRef\n  if (isControlled) {\n    stateRef.current = value;\n  } else {\n    value = stateValue;\n  }\n\n  return [value, setValue];\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */\nexport function clamp(value: number, min: number = -Infinity, max: number = Infinity): number {\n  let newValue = Math.min(Math.max(value, min), max);\n  return newValue;\n}\n\nexport function snapValueToStep(value: number, min: number, max: number, step: number): number {\n  let remainder = ((value - (isNaN(min) ? 0 : min)) % step);\n  let snappedValue = Math.abs(remainder) * 2 >= step\n    ? value + Math.sign(remainder) * (step - Math.abs(remainder))\n    : value - remainder;\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min;\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor((max - min) / step) * step;\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(max / step) * step;\n  }\n\n  // correct floating point behavior by rounding to step precision\n  let string = step.toString();\n  let index = string.indexOf('.');\n  let precision = index >= 0 ? string.length - index : 0;\n\n  if (precision > 0) {\n    let pow = Math.pow(10, precision);\n    snappedValue = Math.round(snappedValue * pow) / pow;\n  }\n\n  return snappedValue;\n}\n\n/* Takes a value and rounds off to the number of digits. */\nexport function toFixedNumber(value: number, digits: number, base: number = 10): number {\n  const pow = Math.pow(base, digits);\n\n  return Math.round(value * pow) / pow;\n}\n"]},"metadata":{},"sourceType":"module"}